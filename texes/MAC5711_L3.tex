% to change the appearance of the header, questions, problems or subproblems, see the homework.cls file or
% override the \Problem, \Subproblem, \question or \printtitle commands.

% The hidequestions option hides the questions. Remove it to print the questions in the text.

\title{MAC5711- Lista 2}

\documentclass{homework}

\usepackage[utf8]{inputenc}
\usepackage{amsthm}
\usepackage{tikz}
\usetikzlibrary{automata,positioning}

\usepackage{graphicx}
\graphicspath{ {images/} }

\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\usepackage[noend]{algpseudocode}


% Set up your name, the course name and the homework set number.
\homeworksetup{
    username={Jean Fobe, N$^o$USP 7630573},
    course={Análise de Algorítmos - MAC5711},
    setnumber=3}
\begin{document}% this also prints the header.
\pagestyle{fancy}
\fancyfoot[L]{Jean Fobe, 7630573}

% use starred problems or subproblems to apply manual numbering.
\problem*{3}
\question{
	Considere o algoritmo ($\mathsf{MaiorMenor}(V,n)$) que calcula o maior e o menor elemento
	de um vetor $v[1 \ ...\ n]$ com elementos distintos. 
	
	\newcommand{\maior}{\mbox{\emph{maior}}}
	\newcommand{\menor}{\mbox{\emph{menor}}}
	
	Suponha que a entrada do algoritmo é uma permutação de 1 a $n$
	escolhida uniformemente dentre todas as permutações de 1 a $n$. 
	
	Qual é o número esperado de comparações executadas na linha 6 do
	algoritmo?\\
	Qual é o número esperado de atribuições efetuadas na
	linha~7 do algoritmo? 
}
	\begin{enumerate}
		\item[Resp:] No pior caso teremos $n-2$ comparações e no melhor caso $0$ comparações, \\
		quando $v[i] > v[1], 1 < i \leq n$.\\
		Admitindo a linearidade (e independência da quantidade de comparações) entre execução do algoritmo e o tamanho do vetor $v$ de entrada, temos que o número esperado de comparações será \[E(n) = \frac{(n-2+0).\frac{n-2}{2}}{(n-2)} = \frac{n-2}{2}\]\\
		Agora para a linha 7 do algoritmo, sabemos que ela só sera executada se a comparação na linha 6 for verdadeira, ou seja, admitindo as mesmas condições da afirmação anterior teremos \[E(n) = \frac{\frac{n-2}{2}}{2} = \frac{n-2}{4}\]\\
		(Lembrando que os valores de $n$ devem ser aqueles para que $E(n)$ é um inteiro positivo)
	\end{enumerate}

\problem*{6}
\question{
	Tanto $\mathsf{Mergesort}$ quanto $\mathsf{Quicksort}$ foram vistos para ordenar um
	vetor. Considere agora o caso em que os dados estão montados numa lista
	(simplesmente) ligada. É importante não piorar a complexidade dos algoritmos;
	deveriam ser mais eficientes que criar um vetor de apontadores para as
	células, ordenar esse vetor conforme o conteúdo das células, e usar esse vetor
	para reordenar as células.  Cada algoritmo traz desafios diferentes:
	\begin{itemize}
	    \item $\mathsf{Mergesort}$: intercalar duas listas ordenadas é fácil.  Mas como
	  dividir uma lista em duas do mesmo tamanho de forma eficiente?  Para vetores,
	  essa divisão era trivial; é preciso tomar cuidado para não aumentar a
	  complexidade do algoritmo.  O gasto de memória deve ser constante, a
	  menos da pilha de recursão.
	
	    \item $\mathsf{Quicksort}$: Aqui o desafio é fazer o particionamento de forma estável
	  e concatenar sublistas rapidamente.  Tente fazer também a forma aleatorizada.
	\end{itemize}
	Em cada caso, justifique a complexidade.
}
	\begin{enumerate}

\pagebreak	
	
		\item[$Resp:$] Segue o algoritmo $\mathsf{MergeSortList}$ (para listas de tamanho de potências de 2):\\
			$\mathsf{MergeSortList}(list\ l)$
			\begin{algorithmic}[1]
				\If {length of {$l \leq 1$}}
					\textbf{return} l
				\EndIf
				\State $left \gets empty list$
				\State $right \gets empty list$
				\For {\textbf{each} $x$ \textbf{with index} $i$ \textbf{in} $l$}
					\If {$i < $ (length of $l$)$/2$}
						\State add x to left
					\Else
						\State add x to right
					\EndIf
				\EndFor
				\State $left \gets MergeSortList(left)$
				\State $right \gets MergeSortList(right)$
				\State \textbf{return} $MergeList(left,right)$
			\end{algorithmic}
			
			$\mathsf{MergeList}(list\ left, list\ right)$
			\begin{algorithmic}[1]
				\State $result \gets empty list$
				\While {left is not empty \textbf{and} right is not empty}
					\If {$first(left) \leq first(right)$}
						\State add first(left) to result
						\State $left \gets rest(left)$
					\Else
						\State add first(right) to result
						\State $right \gets rest(right)$
					\EndIf
				\EndWhile
				\While {left is not empty}
					\State add first(left) to result
					\State $left \gets rest(left)$
				\EndWhile
				\While {right is not empty}
					\State add first(right) to result
					\State $right \gets rest(right)$
				\EndWhile
				\State \textbf{return} result
			\end{algorithmic}
		Observando o algoritmos acima, temos uma grande similaridade com o $\mathsf{MergeSort}(A,p,r)$ visto em sala, as principais mudanças sendo a ordenação de uma lista ao invés de vetor. A chamada $\mathsf{MergeList}$ custa $n = m + o$, em que $m,o$ são os tamanhos das listas da esquerda e direita respectivamente.\\
		Sabendo que $\mathsf{MergeSort}$ é O$(n \lg n)$, podemos ver que $\mathsf{MergeSortList}$ tem o mesmo consumo de tempo para uma lista de tamanho $n$.
		\item[$Resp:$] Segue o algoritmo $\mathsf{QuickSortList}$ (para listas de tamanho de potências de 2):\\
		$\mathsf{QuickSortList}(list\ l, element\ first(list), element\ last(list))$
		\begin{algorithmic}[1]
			\If {$firs(l) < last(l)$}
				\State $split \gets Partition(l,first(l),last(l))$
				\State $QuickSortList(l,first(l),split-1)$
				\State $QuickSortList(l,split+1,last(l))$
			\EndIf
			\State \textbf{return} l
		\end{algorithmic}
		
		$\mathsf{Partition}(list\ l, element\ a, element\ b)$
		\begin{algorithmic}[1]
			\State $pivot \gets first(l)$
			\State $leftmark \gets l.next(a)$
			\State $rightmark \gets b$
			\While {true}
				\While {$leftmark \leq rightmark$ \textbf{and} $leftmark \leq pivot$}
					\State $leftmark \gets l.next(leftmark)$
				\EndWhile
				\While {$rightmark \geq pivot$ \textbf{and} $leftmark \leq rightmark$}
					\State $rightmark \gets l.previous(rightmark)$,ll
				\EndWhile
				\If {$leftmark > rightmark$}
					\State \textbf{return} rightmark
				\Else
					\State $rightmark \longleftrightarrow leftmark$
				\EndIf
			\EndWhile
		\end{algorithmic}

\pagebreak		
		
		Nesse algoritmo	percebemos que $\mathsf{Partition}$ demorar $n2$ no pior caso, uma vez que serão feitas $n$ trocas do tipo $rightmark \longleftrightarrow leftmark$ para uma lista $l$ de tamanho $n$. Adicionalmente a chamada recursiva adiciona $n$ a ordem de grandeza no pior caso, fazendo $\mathsf{QuickSortList}$ demorar $n^2$. Do jeito que foi implementado, $\mathsf{QuickSortList}$ não é estável, pois não se mantém as referências das trocas realizadas.
		
	\end{enumerate}
\end{document}