}
if ( x == 1 ) {
return (pow2array);
}
return (collatzPows(3*x+1, pow2array));
}
collatzLog2 <- function (n, pow2array) {
if ( length(pow2array) == 1 ) {
return (
log2(3*n + 1) #/ 2^(pow2array[1])
);
}
return (log2(sum
(unlist
(lapply(2:length(pow2array)-1,
FUN=function(X) {
3^(length(pow2array)-X-1)*2^(sum(pow2array[1:X]))
}
)
)
) + 3^(length(pow2array))*n + 3^(length(pow2array)-1)
) #/ 2^(sum(pow2array))
);
}
collatzCheck <- function (n, pow2array) {
if ( length(pow2array) == 1 ) {
return (
(3*n + 1) / 2^(pow2array[1])
);
}
return ((sum
(unlist
(lapply(2:length(pow2array)-1,
FUN=function(X) {
3^(length(pow2array)-X-1)*2^(sum(pow2array[1:X]))
}
)
)
) + 3^(length(pow2array))*n + 3^(length(pow2array)-1)
) / 2^(sum(pow2array))
);
}
collatzFuzz <- function (pow2array) {
if ( length(pow2array) == 1 ) {
# if ( pow2array[1] % 2) {
return (
(2^(pow2array[1])-1) / 3
);
# } else {
#   return (2^(pow2array));
# }
}
return (
(-(sum(unlist
(lapply(2:length(pow2array)-1,
FUN=function(X) {
3^(length(pow2array)-X-1)*2^(sum(pow2array[1:X]))
}
)
)
)) - 3^(length(pow2array)-1)  + 2^(sum(pow2array))
) /(3^(length(pow2array)))
);
}
collatzExpand <- function(pow2array, s=c()) {
if ( length(pow2array) == 1 ) {
return (c((2^(pow2array[1])-1)/3,s));
}
return (collatzExpand(pow2array[1:length(pow2array)-1], c((2^(pow2array[length(pow2array)])-1)/3,s)))
}
collatzPows <- function (x, pow2array = c()) {
itx = 0;
while ( x %% 2 != 1 ) {
x = x / 2;
itx = itx + 1;
}
if ( itx != 0 ) {
pow2array = c(pow2array,itx);
}
if ( x == 1 ) {
return (pow2array);
}
return (collatzPows(3*x+1, pow2array));
}
collatzLog2 <- function (n, pow2array) {
if ( length(pow2array) == 1 ) {
return (
log2(3*n + 1) #/ 2^(pow2array[1])
);
}
return (log2(sum
(unlist
(lapply(2:length(pow2array)-1,
FUN=function(X) {
3^(length(pow2array)-X-1)*2^(sum(pow2array[1:X]))
}
)
)
) + 3^(length(pow2array))*n + 3^(length(pow2array)-1)
) #/ 2^(sum(pow2array))
);
}
collatzCheck <- function (n, pow2array) {
if ( length(pow2array) == 1 ) {
return (
(3*n + 1) / 2^(pow2array[1])
);
}
return ((sum
(unlist
(lapply(2:length(pow2array)-1,
FUN=function(X) {
3^(length(pow2array)-X-1)*2^(sum(pow2array[1:X]))
}
)
)
) + 3^(length(pow2array))*n + 3^(length(pow2array)-1)
) / 2^(sum(pow2array))
);
}
collatzFuzz <- function (pow2array) {
if ( length(pow2array) == 1 ) {
if ( pow2array[1] %% 2) {
return (
(2^(pow2array[1])-1) / 3
);
} else {
return (2^(pow2array[1]));
}
}
return (
(-(sum(unlist
(lapply(2:length(pow2array)-1,
FUN=function(X) {
3^(length(pow2array)-X-1)*2^(sum(pow2array[1:X]))
}
)
)
)) - 3^(length(pow2array)-1)  + 2^(sum(pow2array))
) /(3^(length(pow2array)))
);
}
collatzExpand <- function(pow2array, s=c()) {
if ( length(pow2array) == 1 ) {
return (c((2^(pow2array[1])-1)/3,s));
}
return (collatzExpand(pow2array[1:length(pow2array)-1], c((2^(pow2array[length(pow2array)])-1)/3,s)))
}
collatzFuzz(collatzPows(14))
collatzPows <- function (x, pow2array = c()) {
itx = 0;
while ( x %% 2 != 1 ) {
x = x / 2;
itx = itx + 1;
}
if ( itx != 0 ) {
pow2array = c(pow2array,itx);
}
if ( x == 1 ) {
return (pow2array);
}
return (collatzPows(3*x+1, pow2array));
}
collatzLog2 <- function (n, pow2array) {
if ( length(pow2array) == 1 ) {
return (
log2(3*n + 1) #/ 2^(pow2array[1])
);
}
return (log2(sum
(unlist
(lapply(2:length(pow2array)-1,
FUN=function(X) {
3^(length(pow2array)-X-1)*2^(sum(pow2array[1:X]))
}
)
)
) + 3^(length(pow2array))*n + 3^(length(pow2array)-1)
) #/ 2^(sum(pow2array))
);
}
collatzCheck <- function (n, pow2array) {
if ( length(pow2array) == 1 ) {
return (
(3*n + 1) / 2^(pow2array[1])
);
}
return ((sum
(unlist
(lapply(2:length(pow2array)-1,
FUN=function(X) {
3^(length(pow2array)-X-1)*2^(sum(pow2array[1:X]))
}
)
)
) + 3^(length(pow2array))*n + 3^(length(pow2array)-1)
) / 2^(sum(pow2array))
);
}
collatzFuzz <- function (pow2array) {
if ( length(pow2array) == 1 ) {
if ( !pow2array[1] %% 2) {
return (
(2^(pow2array[1])-1) / 3
);
} else {
return (2^(pow2array[1]));
}
}
return (
(-(sum(unlist
(lapply(2:length(pow2array)-1,
FUN=function(X) {
3^(length(pow2array)-X-1)*2^(sum(pow2array[1:X]))
}
)
)
)) - 3^(length(pow2array)-1)  + 2^(sum(pow2array))
) /(3^(length(pow2array)))
);
}
collatzExpand <- function(pow2array, s=c()) {
if ( length(pow2array) == 1 ) {
return (c((2^(pow2array[1])-1)/3,s));
}
return (collatzExpand(pow2array[1:length(pow2array)-1], c((2^(pow2array[length(pow2array)])-1)/3,s)))
}
collatzFuzz(collatzPows(14))
collatzFuzz(collatzPows(13))
collatzPows <- function (x, pow2array = c()) {
itx = 0;
while ( x %% 2 != 1 ) {
x = x / 2;
itx = itx + 1;
}
if ( itx != 0 ) {
pow2array = c(pow2array,itx);
}
if ( x == 1 ) {
return (pow2array);
}
return (collatzPows(3*x+1, pow2array));
}
collatzLog2 <- function (n, pow2array) {
if ( length(pow2array) == 1 ) {
return (
log2(3*n + 1) #/ 2^(pow2array[1])
);
}
return (log2(sum
(unlist
(lapply(2:length(pow2array)-1,
FUN=function(X) {
3^(length(pow2array)-X-1)*2^(sum(pow2array[1:X]))
}
)
)
) + 3^(length(pow2array))*n + 3^(length(pow2array)-1)
) #/ 2^(sum(pow2array))
);
}
collatzCheck <- function (n, pow2array) {
if ( length(pow2array) == 1 ) {
return (
(3*n + 1) / 2^(pow2array[1])
);
}
return ((sum
(unlist
(lapply(2:length(pow2array)-1,
FUN=function(X) {
3^(length(pow2array)-X-1)*2^(sum(pow2array[1:X]))
}
)
)
) + 3^(length(pow2array))*n + 3^(length(pow2array)-1)
) / 2^(sum(pow2array))
);
}
collatzFuzz <- function (pow2array) {
if ( length(pow2array) == 1 ) {
if ( !pow2array[1] %% 2) {
return (
(2^(pow2array[1])-1) / 3
);
} else {
return (2^(pow2array[1]) * 3 + 1);
}
}
return (
(-(sum(unlist
(lapply(2:length(pow2array)-1,
FUN=function(X) {
3^(length(pow2array)-X-1)*2^(sum(pow2array[1:X]))
}
)
)
)) - 3^(length(pow2array)-1)  + 2^(sum(pow2array))
) /(3^(length(pow2array)))
);
}
collatzExpand <- function(pow2array, s=c()) {
if ( length(pow2array) == 1 ) {
return (c((2^(pow2array[1])-1)/3,s));
}
return (collatzExpand(pow2array[1:length(pow2array)-1], c((2^(pow2array[length(pow2array)])-1)/3,s)))
}
collatzFuzz(collatzPows(13))
collatzFuzz(collatzPows(14))
collatzFuzz(collatzPows(14)) * 3 + 1
collatzFuzz(collatzPows(15)) * 3 + 1
collatzFuzz(collatzPows(46)) * 3 + 1
lapply(1:10, FUN = sum())
lapply(1:10, FUN = sum
)
sum(lapply(1:10, FUN = sum))
ls
rm(pow2sarray)
collatzPows(3)
collatzFuzz(c(3,3))
collatzFuzz(c(1,4))
1 %/% .2
ls()
help("seq")
collatzPows(seq(from = 11, to = 1111, by = 2))
warnings
(seq(from = 11, to = 111, by = 2))
lapply(seq(from = 11, to = 111, by = 2), FUN = collatzPows)
length(lapply(seq(from = 11, to = 111, by = 2), FUN = collatzPows))
lapply(seq(from = 11, to = 111, by = 2), FUN = collatzPows)[51]
lapply(seq(from = 11, to = 111, by = 2), FUN = collatzPows)[50]
length(lapply(seq(from = 11, to = 111, by = 2), FUN = collatzPows)[50])
length(unlist(lapply(seq(from = 11, to = 111, by = 2), FUN = collatzPows)[50]))
sum(unlist(lapply(seq(from = 11, to = 111, by = 2), FUN = collatzPows)[50]))/41
lapply(lapply(seq(from = 11, to = 111, by = 2), FUN = collatzPows), FUN = function (X){sum(X)/length(X)})
lapply(seq(from = 11, to = 111, by = 2), FUN = collatzPows)[9]
lapply(seq(from = 11, to = 111, by = 2), FUN = collatzPows)[50]
lapply(seq(from = 11, to = 111, by = 2), FUN = collatzPows)
collatzFuzz(c(1, 2, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 4, 2, 2, 4, 3, 1, 1, 5, 4))
collatzPows(81)
collatzPows(3)
collatzPows(9)
collatzPows(27)
collatzPows(243)
collatzPows(3**3)
collatzPows(3**5)
collatzPows(3**6)
collatzPows(3**7)
collatzPows(3**8)
collatzPows(3**9)
collatzPows(3**10)
collatzFuzz(c(1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 4, 2, 2, 4, 3, 1, 1, 5, 4))
collatzFuzz(c(2, 1, 2, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 4, 2, 2, 4, 3, 1, 1, 5, 4))
collatzFuzz(c(3, 1, 2, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 4, 2, 2, 4, 3, 1, 1, 5, 4))
collatzFuzz(c(1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 4, 2, 2, 4, 3, 1, 1, 5, 4))
collatzFuzz(c(2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 4, 2, 2, 4, 3, 1, 1, 5, 4))
collatzFuzz(c(3, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 4, 2, 2, 4, 3, 1, 1, 5, 4))
collatzFuzz(c(4, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 4, 2, 2, 4, 3, 1, 1, 5, 4))
collatzFuzz(c(5, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 4, 2, 2, 4, 3, 1, 1, 5, 4))
collatzFuzz(c(1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 4, 2, 2, 4, 3, 1, 1, 5, 4))
collatzFuzz(c(2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 4, 2, 2, 4, 3, 1, 1, 5, 4))
collatzFuzz(c(3, 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 4, 2, 2, 4, 3, 1, 1, 5, 4))
collatzFuzz(c(3, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 4, 2, 2, 4, 3, 1, 1, 5, 4))
collatzFuzz(c(4, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 4, 2, 2, 4, 3, 1, 1, 5, 4))
collatzFuzz(c(2, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 4, 2, 2, 4, 3, 1, 1, 5, 4))
setwd("~/projects/ime/eps/mac5832_kaggle/")
names(data)
data <- read.csv(file = "train.csv");
names(data)
data[1,]
2**(-7.8)
if(!require("install.load")) {install.packages("install.load"); library("install.load")}
lapply(c('foreach', 'doParallel', 'parallel', 'e1071', 'parallelSVM', 'caret', 'pROC'),
FUN = function(X){
if(!X %in% installed.packages()) {
install_load(X);
}
});
doParallel::registerDoParallel(cores = parallel::detectCores()-1);
data <- read.csv(file = "train.csv");
test <- read.csv(file = "test.csv");
## encode data to apply learning methods
conv2numeric <- c("job", "marital", "education", "default", "housing", "loan", "contact", "poutcome");
data[, conv2numeric] <- sapply(data[, conv2numeric], FUN = as.numeric);
test[, conv2numeric] <- sapply(test[, conv2numeric], FUN = as.numeric);
x <- subset(data, select = c(-y,-id));
y <- subset(data, select = y);
## woah - cannot use just 't', apparently messes with built-in functions:
## https://stats.stackexchange.com/questions/233531/object-of-type-closure-is-not-subsettable
test_t <- subset(test, select = c(-id));
svm_model <- parallelSVM::parallelSVM(x, y$y,
probability = TRUE,
gamma=0.004487103, cost = 3,
numberCores = parallel::detectCores()-1);
summary(svm_model);
## performance
system.time(pred <- predict(svm_model, x));
pred_numeric <- as.double(as.character(pred));
pred_numeric[pred_numeric < 0] <- 0.0;
get_perf <- function(a,b) {return (min(a,b)/max(a,b));}
cat("Performance : [",
(get_perf(length(round(pred_numeric)[round(pred_numeric) == 1]), length(y$y[y$y == 1])) +
get_perf(length(round(pred_numeric)[round(pred_numeric) == 0]), length(y$y[y$y == 0])))/2, "]\n");
system.time(pred <- predict(svm_model, test_t));
pred_numeric <- as.double(as.character(pred));
pred_numeric[pred_numeric < 0] <- 0.0;
pred_numeric[round(pred_numeric) > 0]
length(pred_numeric[round(pred_numeric) > 0])
svm_model <- parallelSVM::parallelSVM(x, y$y,
type = "C-classification",
probability = TRUE,
gamma = 0.004487103, cost = 3,
numberCores = parallel::detectCores()-1);
summary(svm_model);
## performance
system.time(pred <- predict(svm_model, x));
pred_numeric <- as.double(as.character(pred));
pred_numeric[pred_numeric < 0] <- 0.0;
get_perf <- function(a,b) {return (min(a,b)/max(a,b));}
cat("Performance : [",
(get_perf(length(round(pred_numeric)[round(pred_numeric) == 1]), length(y$y[y$y == 1])) +
get_perf(length(round(pred_numeric)[round(pred_numeric) == 0]), length(y$y[y$y == 0])))/2, "]\n");
system.time(pred <- predict(svm_model, test_t));
pred_numeric <- as.double(as.character(pred));
pred_numeric[pred_numeric < 0] <- 0.0;
length(pred_numeric[round(pred_numeric) > 0])
svm_model <- parallelSVM::parallelSVM(x, y$y,
type = "C-classification",
kernel = "linear",
probability = TRUE,
gamma = 0.004487103, cost = 3,
numberCores = parallel::detectCores()-1);
summary(svm_model);
## performance
system.time(pred <- predict(svm_model, x));
pred_numeric <- as.double(as.character(pred));
pred_numeric[pred_numeric < 0] <- 0.0;
get_perf <- function(a,b) {return (min(a,b)/max(a,b));}
cat("Performance : [",
(get_perf(length(round(pred_numeric)[round(pred_numeric) == 1]), length(y$y[y$y == 1])) +
get_perf(length(round(pred_numeric)[round(pred_numeric) == 0]), length(y$y[y$y == 0])))/2, "]\n");
system.time(pred <- predict(svm_model, test_t));
pred_numeric <- as.double(as.character(pred));
pred_numeric[pred_numeric < 0] <- 0.0;
length(pred_numeric[round(pred_numeric) > 0])
pnl <- pred_numeric
svm_model <- parallelSVM::parallelSVM(x, y$y,
type = "C-classification",
kernel = "radial",
probability = TRUE,
gamma = 0.004487103, cost = 3,
numberCores = parallel::detectCores()-1);
summary(svm_model);
## performance
system.time(pred <- predict(svm_model, x));
pred_numeric <- as.double(as.character(pred));
pred_numeric[pred_numeric < 0] <- 0.0;
get_perf <- function(a,b) {return (min(a,b)/max(a,b));}
cat("Performance : [",
(get_perf(length(round(pred_numeric)[round(pred_numeric) == 1]), length(y$y[y$y == 1])) +
get_perf(length(round(pred_numeric)[round(pred_numeric) == 0]), length(y$y[y$y == 0])))/2, "]\n");
system.time(pred <- predict(svm_model, test_t));
pred_numeric <- as.double(as.character(pred));
pred_numeric[pred_numeric < 0] <- 0.0;
pnr <- pred_numeric
pnl == plr
pnl == pnr
pnr[pnl != pnr]
length(pred_numeric[round(pred_numeric) > 0])
pnl[pnl != pnr]
seed <- set.seed(
as.numeric(
format(Sys.Date(), "%Y")));
seed
seed <-
as.numeric(
format(Sys.Date(), "%Y"));
seed
svmseed <- as.numeric(format(Sys.Date(), "%Y"));
set.seed(svmseed);
doParallel::registerDoParallel(cores = parallel::detectCores()-1);
data <- read.csv(file = "train.csv");
test <- read.csv(file = "test.csv");
## encode data to apply learning methods
conv2numeric <- c("job", "marital", "education", "default", "housing", "loan", "contact", "poutcome");
data[, conv2numeric] <- sapply(data[, conv2numeric], FUN = as.numeric);
test[, conv2numeric] <- sapply(test[, conv2numeric], FUN = as.numeric);
x <- subset(data, select = c(-y,-id));
y <- subset(data, select = y);
## woah - cannot use just 't', apparently messes with built-in functions:
## https://stats.stackexchange.com/questions/233531/object-of-type-closure-is-not-subsettable
test_t <- subset(test, select = c(-id));
svm_model <- parallelSVM::parallelSVM(x, y$y,
type = "C-classification",
kernel = "radial",
seed = svmseed,
probability = TRUE,
gamma = 0.004487103, cost = 3,
numberCores = parallel::detectCores()-1);
summary(svm_model);
## performance
system.time(pred <- predict(svm_model, x));
pred_numeric <- as.double(as.character(pred));
pred_numeric[pred_numeric < 0] <- 0.0;
get_perf <- function(a,b) {return (min(a,b)/max(a,b));}
cat("Performance : [",
(get_perf(length(round(pred_numeric)[round(pred_numeric) == 1]), length(y$y[y$y == 1])) +
get_perf(length(round(pred_numeric)[round(pred_numeric) == 0]), length(y$y[y$y == 0])))/2, "]\n");
system.time(pred <- predict(svm_model, test_t));
pred_numeric <- as.double(as.character(pred));
pred_numeric[pred_numeric < 0] <- 0.0;
length(pred_numeric[round(pred_numeric) > 0])
